// ===================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// ===================================================================
// Generated by: scripts/generate-extension-types.ts
// Generated at: 2026-01-10T14:22:47.898Z
// 
// This file provides CNTX type substitution for extension interfaces.
// Extension interfaces are defined with placeholder types at component
// definition time, but need concrete CNTX instances when builders are
// created. The ExtensionOf type performs this substitution.
//
// To regenerate: npm run generate:extension-types
//
// Detected extensions:
//   - SingleItemContainerExtension
//   - ElementSetContainerExtension
//   - TableExtension
// ===================================================================

import type { ComponentWrapper } from '../components/ReComponentWrapper';
import type { 
  CNTX,
  ReUiPlanComponentBuilder,
  ReBuilderBase, 
  FluentSimple,
  FluentSubBuilder
} from './ReUiPlanBuilder';

import {SingleItemContainerExtension, SimplifiedReUiPlanComponentBuilder, ElementSetContainerExtension, ReUiPlanElementSetBuilder} from '../components/ContainerElements.js';
import {TableExtension, ColumnBuilder, FilterBuilder} from '../../components/tables/table.js';

/**
 * Maps extension methods to properly substitute CNTX and RT types.
 * Handles: SingleItemContainerExtension, ElementSetContainerExtension, TableExtension
 */
export type ExtensionOf<C extends CNTX, T extends ComponentWrapper<any, any>, BLD = unknown, RT = any> =
  T extends ComponentWrapper<infer P, infer E>
    ? E extends object
      ?   // Handle SingleItemContainerExtension
         SingleItemContainerExtension<any, any> extends E
         ? { [K in keyof E]:
             // calculate the new return type
             E[K] extends ((...args: infer A) => infer R) // check for functions
               //  we are a function
               ? R extends FluentSimple  //check for simple pattern #1
                 // yes we are simple pattern #1
                 ? ((...args: A) => ReUiPlanComponentBuilder<C, T, RT> & SingleItemContainerExtension<C, RT>)
                 // not simple pattern #1, check for pattern #2
                 : R extends FluentSubBuilder<infer BLD2> // check for sub-builder pattern #2
                   ? BLD2 extends SimplifiedReUiPlanComponentBuilder<C, any>
                     ? ((...args: A) => SimplifiedReUiPlanComponentBuilder<C, ComponentBuilderWithExt<C, T, RT>>)
                     : E[K]
                   : E[K] // not pattern #2 either
               // we are not a function
               : E[K]
           }
       // Handle ElementSetContainerExtension
      :  ElementSetContainerExtension<any, any> extends E
         ? { [K in keyof E]:
             // calculate the new return type
             E[K] extends ((...args: infer A) => infer R) // check for functions
               //  we are a function
               ? R extends FluentSimple  //check for simple pattern #1
                 // yes we are simple pattern #1
                 ? ((...args: A) => ReUiPlanComponentBuilder<C, T, RT> & ElementSetContainerExtension<C, RT>)
                 // not simple pattern #1, check for pattern #2
                 : R extends FluentSubBuilder<infer BLD2> // check for sub-builder pattern #2
                   ? BLD2 extends ReUiPlanElementSetBuilder<C, any>
                     ? ((...args: A) => ReUiPlanElementSetBuilder<C, ComponentBuilderWithExt<C, T, RT>>)
                     : E[K]
                   : E[K] // not pattern #2 either
               // we are not a function
               : E[K]
           }
       // Handle TableExtension
      :  TableExtension<any, any> extends E
         ? { [K in keyof E]:
             // calculate the new return type
             E[K] extends ((...args: infer A) => infer R) // check for functions
               //  we are a function
               ? R extends FluentSimple  //check for simple pattern #1
                 // yes we are simple pattern #1
                 ? ((...args: A) => ReUiPlanComponentBuilder<C, T, RT> & TableExtension<C, RT>)
                 // not simple pattern #1, check for pattern #2
                 : R extends FluentSubBuilder<infer BLD2> // check for sub-builder pattern #2
                   ? BLD2 extends ColumnBuilder<C, any>
                     ? ((...args: A) => ColumnBuilder<C, ComponentBuilderWithExt<C, T, RT>>)
                   : BLD2 extends FilterBuilder<C, any>
                     ? ((...args: A) => FilterBuilder<C, ComponentBuilderWithExt<C, T, RT>>)
                     : E[K]
                   : E[K] // not pattern #2 either
               // we are not a function
               : E[K]
           }
      : E  // Fallback: not a recognized extension, return as-is
    : E
  : never;


export type ReturnTypeOf<R> =
  R extends ReBuilderBase<any> ? (R extends ReBuilderBase<infer RT> ? RT : never) : never;


// Re-export for convenience
export type ComponentBuilderWithExt<C extends CNTX, T extends ComponentWrapper<any, any>, RT> = 
  ReUiPlanComponentBuilder<C, T, RT> & ExtensionOf<C, T, ReUiPlanComponentBuilder<C, T, RT>, RT>;
