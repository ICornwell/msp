// ===================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// ===================================================================
// Generated by: scripts/generate-extension-types.ts
// Generated at: 2025-12-18T19:18:45.915Z
// 
// This file provides CNTX type substitution for extension interfaces.
// Extension interfaces are defined with placeholder types at component
// definition time, but need concrete CNTX instances when builders are
// created. The ExtensionOf type performs this substitution.
//
// To regenerate: npm run generate:extension-types
//
// Detected extensions:
//   - SingleItemContainerExtension (containingSingle)
//   - ElementSetContainerExtension (containingElementSet)
//   - TableExtension (forDataType)
// ===================================================================

import type { ComponentWrapper } from '../components/ReComponentWrapper';
import type { 
  CNTX,
  ReUiPlanComponentBuilder,
  ReBuilderBase, 
  FluentSimple,
  FluentSubBuilder
} from './ReUiPlanBuilder';

import {SingleItemContainerExtension, ElementSetContainerExtension} from '../components/ContainerElements.tsx';
import {TableExtension, ColumnBuilder, FilterBuilder, TableComponent} from '../../components/tables/table.tsx';

/**
 * Maps extension methods to properly substitute CNTX and RT types.
 * Handles: SingleItemContainerExtension, ElementSetContainerExtension, TableExtension
 */
export type ExtensionOf<C extends CNTX, T extends ComponentWrapper<any, any>, BLD = unknown, RT = any> =
  T extends ComponentWrapper<infer P, infer E>
    ? E extends object
      ?   // Handle SingleItemContainerExtension
         SingleItemContainerExtension<any, any> extends E
         ? { [K in keyof E]:
             E[K] extends ((...args: infer A) => infer R)
               ? R extends SingleItemContainerExtension <any, any>
                 ? (...args: A) => SingleItemContainerExtension<C, BLD & ExtensionOf<C, T, BLD, RT>>
                 : R extends ReBuilderBase<any>
                   ? E[K]
                   : (...args: A) => BLD & ExtensionOf<C, T, BLD, RT>
               : E[K]
           }
       // Handle ElementSetContainerExtension
      :  ElementSetContainerExtension<any, any> extends E
         ? { [K in keyof E]:
             E[K] extends ((...args: infer A) => infer R)
               ? R extends ElementSetContainerExtension <any, any>
                 ? (...args: A) => ElementSetContainerExtension<C, BLD & ExtensionOf<C, T, BLD, RT>>
                 : R extends ReBuilderBase<any>
                   ? E[K]
                   : (...args: A) => BLD & ExtensionOf<C, T, BLD, RT>
               : E[K]
           }
       // Handle TableExtension
      :  TableExtension<any, any> extends E
         ? { [K in keyof E]:
             // calculate the new return type
             E[K] extends ((...args: infer A) => infer R) // check for functions
               //  we are a function
               ? R extends FluentSimple  //check for simple pattern #1
                 // yes we are simple pattern #1
                 ? ((...args: A) => ReUiPlanComponentBuilder<C, T, RT> & TableExtension<C, RT>)
                 // not simple pattern #1, check for pattern #2
                 : R extends FluentSubBuilder<infer BLD2> // check for sub-builder pattern #2
                   ? BLD2 extends ColumnBuilder<C, any>
                     ? ((...args: A) => ColumnBuilder<C, ComponentBuilderWithExt<C, typeof TableComponent, RT>>)
                   : BLD2 extends FilterBuilder<C, any>
                     ? ((...args: A) => FilterBuilder<C, ComponentBuilderWithExt<C, typeof TableComponent, RT>>)
                     : never
                   : never // not pattern #2 either
               // we are not a function
               : E[K]
           }
      : E  // Fallback: not a recognized extension, return as-is
    : never
  : never;


export type ReturnTypeOf<R> =
  R extends ReBuilderBase<any> ? (R extends ReBuilderBase<infer RT> ? RT : never) : never;


// Re-export for convenience
export type ComponentBuilderWithExt<C extends CNTX, T extends ComponentWrapper<any, any>, RT> = 
  ReUiPlanComponentBuilder<C, T, RT> & ExtensionOf<C, T, ReUiPlanComponentBuilder<C, T, RT>, RT>;
